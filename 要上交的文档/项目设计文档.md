# 项目设计文档
## 1. 项目概述
诗韵盛会是一个致力于促进诗词文化传承与交流的在线平台，采用了前后端分离的架构。前端基于Vue.js构建，并结合Vuex进行状态管理，使用Quasar组件库打造现代化的用户界面，通过Axios与后端进行通信，并使用WebSocket实现实时互动；后端使用Spring Boot框架，结合Spring MVC构建RESTful API，使用Spring Data JPA与MySQL进行数据交互。为了确保开发环境和生产环境的一致性以及高效的部署，平台采用了Docker进行容器化管理。

## 2. 功能项表
| 功能项       | 评分指标                     | 完成情况 |
| --------- | ------------------------ | ---- |
| **基本功能**  |                          |      |
| UI和交互     | UI设计合理，具有较好的用户体验         | ✅    |
| 基本页面与流程   | 登录和注册功能使用正常              | ✅    |
|           | 后端用户管理功能                 | ✅    |
| 虚拟场景以及交互  | 可交互的3D场景建模合理，用户体验好       | ✅    |
|           | 场景功能的完成度和交互的丰富程度         | ✅    |
|           | 支持多人加入该场景，并实现行为共享        | ✅    |
|           | 支持用户间的文本、动作等方式交流         | ✅    |
| 工程能力      | 文档说明清晰、详细，图文并茂，图示准确      | ✅    |
|           | 系统架构设计合理规范               | ✅    |
|           | 代码清晰，风格合理，具有良好的设计模式      | ✅    |
|           | 服务部署在云平台上，具有很好的可访问性      | ✅    |
| **进阶功能**  |                          |      |
| AI能力      | 响应用户虚拟行为的智能导师            | ✅    |
| 语义Web     | 虚拟场景中的实体添加语义描述           | ✅    |
| 交互性       | 创新交互与多模式交流支持（如WebRTC）    | ✅    |
| 云计算应用     | 合理采用 Docker 以及多种云服务      | ✅    |
| 微服务       | 对项目进行微服务拆分               | ✅    |
| 用户个性化统计信息 | 多维度展现用户的学习情况，同时引入错题分析与推荐 | ✅    |
| 用户体验优化    | 进度条加载                    | ✅    |
|           | 不同人物的待机动作展示              | ✅    |
|           | 设置不同的主题房间                | ✅    |


## 3.  项目组织文件说明
```
.
├── poem-learning-platform  # 前端
└── poetryconference-parent # 后端
    ├── ai-chat-service
    ├── api-gateway
    ├── eureka-server
    ├── poem-service
    └── user-service
```
### 3.2 前端部分
```
├── App.vue
├── assets # 前端呈现所需资源
│   ├── animation # 动画
│   ├── img # 图片
│   ├── model # 模型
│   ├── owl # 语义描述
│   └── textures # 3D场景图片
├── fonts # 字体
├── main.js
├── quasar-variables.sass
├── router # 前端路由
│   └── index.js
├── scripts
│   ├── communications.js
│   ├── font.js # 导入字体
│   ├── loader.js # 导入模型和动画
│   ├── physics.js # 碰撞检测，物理引擎
│   ├── player.js # 玩家
│   ├── rng.js # 生成随机序列
│   ├── screen.js # 在3D屏幕上显示相关内容
│   ├── simplepeer.min.js 
│   ├── ui.js # 便于编写时调试的ui
│   ├── webrtc.js # webrtc
│   ├── world.js # 大世界
│   └── worldChunk.js # 大世界中的块
├── store
│   └── index.js # Vuex的store配置文件
└── views
    ├── LoginPage.vue # 登陆页面
    ├── MainPage.vue # 主页面
    ├── OpenView.vue # 开机动画页面
    ├── PersonPage.vue # 错题回顾页面
    ├── ProgressBar.vue # 3D场景进度条
    ├── RegisterPage.vue # 注册页面
    └── scene.vue # 3D场景
```
### 3.3 后端部分

```
└── poetryconference-parent 
    ├── ai-chat-service 	# AI智能导师服务
    ├── api-gateway 		# API网关服务
    ├── eureka-server 		# 服务注册中心
    ├── poem-service 		# 诗歌服务
    └── user-service 		# 用户管理服务
```

## 4.  关键功能的实现细节
### 4.1 AI智能导师
#### 概述

AI智能导师是一个利用人工智能技术，为用户提供智能问答和学习辅助的服务。该服务能够理解用户的自然语言输入，进行语义分析并生成相应的回答或建议。

#### 实现原理

AI智能导师的实现基于对多个高级人工智能模型的调用和集成。在本项目中，主要通过调用通义千问和Kimi的API来实现核心功能。这些API提供了强大的自然语言处理能力，使得AI智能导师能够理解和生成自然语言文本。以下是具体的实现原理：

1. **设置系统提示(system prompt)：**

   在调用API时，可以通过设置系统提示来引导模型的回答风格和内容。系统提示可以包含对回答格式、语气、内容范围等的指示。

   ```java
   Message systemMsg = Message.builder()
                   .role(Role.SYSTEM.getValue())
                   .content("你是一个擅长中国诗歌的智慧助手，你的名字叫螺丝咕姆.")
                   .build();
   ```

2. **用户输入处理**：

   - 用户通过前端界面输入问题或请求，输入的文本通过API网关发送到`ai-chat-service`微服务。

   - `ai-chat-service`接收到用户输入后，进行预处理，包括文本清洗和格式化，确保输入文本符合API调用要求。

3. **调用第三方大模型API**：

   - `ai-chat-service`通过HTTP请求，选择调用通义千问或Kimi的API，将用户的输入传递给第三方大模型模型。

   - 第三方大模型API接收输入后，利用其强大的自然语言处理能力进行语义分析和理解，从其庞大的知识库中检索相关信息，生成初步回答。

   - 第三方大模型API返回生成的回答文本到`ai-chat-service`。

4. **答案整合与返回**：

   - `ai-chat-service`整合从通义千问和Kimi获取的回答，进行必要的格式化和调整，确保答案的完整性和易读性。

   - 最终的回答通过API网关返回给前端界面，用户可以在界面上查看AI智能导师生成的回答。

通过调用通义千问和Kimi的API，AI智能导师实现了高效的自然语言理解和生成，能够为用户提供准确、及时的智能问答服务。这种集成多模型、多API的方式，确保了系统的鲁棒性和智能化水平，使得AI智能导师在各类应用场景中都能发挥重要作用。

### 4.2 语义描述
#### 概述
对于3D场景中的实体块，定义实体类别和属性，通过RDF/OWL语法将实体与其属性关联起来，生成语义描述，使AI能够理解和处理这些实体及其关系。
#### 实现原理
从指定路径加载OWL文件并解析其内容，提取RDF数据生成关系对象。具体过程如下：
1. **编写OWL文件：** 定义实体类别，属性以及之间的关系。
2. **加载和解析 OWL 文件：** 从指定路径加载 OWL 文件。使用 `fetch` API 获取文件内容，然后使用 RDFLib 库解析 RDF 数据。解析后的数据存储在一个三元组图中，方便后续处理。
3. **提取 RDF 数据：** 从 RDF 图中提取有用的信息，包括类定义、属性定义和实体关系。将这些信息分类存储在对象中：
	- **类定义**：记录每个类及其对应的类型。
	- **属性定义**：记录每个属性及其对应的类型和对象。
	- **实体关系**：记录实体之间的关系，包括主语、谓语和宾语。
4. **使用 Three.js 进行可视化：** 最后，我们利用提取的信息创建一个 Three.js 场景，展示实体之间的关系。例如，对于 `airWallBlock` 类，我们将其关系数据转换为 Three.js 的实例化网格对象，并将其用户数据设为提取的信息。
### 4.3 WebRTC
#### 概述
WebRTC通过简单的API实现浏览器和移动应用之间的实时音视频通信以及数据共享,实现点对点（peer-to-peer）的实时通信功能。
#### 实现原理
1. **创建本地流：** 使用 `navigator.mediaDevices.getUserMedia()` 获取本地音视频流。
2. **信令服务器**：通过WebSocket连接与信令服务器进行通信，用于交换配置信息和建立点对点连接。处理各种消息类型，如数据传输、对等方连接和断开连接、信号交换等
3. **创建 PeerConnection：** 使用 `RTCPeerConnection` 创建本地和远程的连接。发送和接收媒体流。
4. **DOM操作**：创建和更新对等方的视频和音频元素，管理连接和断开连接的对等方DOM元素。
5. **处理媒体流**：获取用户的本地媒体流（音频和视频），并处理媒体约束（如分辨率和帧率）。
6. **后端服务器处理** 通过peer数组存储所有的peer，防止连接重复，并通过websocket实现消息的传递。
### 4.4 Docker及部署
#### 概述
使用 Docker 容器技术，将项目部署在云平台上，实现云端的可扩展性和弹性伸缩。
#### 实现原理
1. **Dockerfile 编写：** 编写 Dockerfile 文件，定义镜像的基础环境、安装依赖、添加应用文件等。

   这里仅展示mysql服务 Dockerfile的编写：

   ```yml
   # 使用官方 MySQL 镜像作为基础
   FROM mysql:8.0
   
   # 设置环境变量
   ENV MYSQL_ROOT_PASSWORD=123456
   ENV MYSQL_DATABASE=poetry
   
   # 拷贝初始化 SQL 脚本到容器中
   COPY ./init.sql /docker-entrypoint-initdb.d/
   
   # 公开端口 3306
   EXPOSE 3306
   ```

2. **镜像构建：** 使用 Docker 客户端构建镜像，生成 Docker 镜像。

   * 对于Spring Cloud 项目，采用IDEA插件一键构建：
     * 打开`IntelliJ IDEA`
     * `Maven` -> `$Project` -> `Plugins` -> `spring-boot` -> `spring-boot: build-image`
   * 对于数据库和前端服务，采用`docker build . -t`构建。

3. **在服务器上加载镜像:** 将 Docker 镜像从本机环境传输到服务器环境。

   以user-service image的传输为例：

   ```shell
   docker save zsq0216/user-service:latest > user-service.tar # 保存docker镜像为tar文件
   scp user-service.tar root@121.196.228.112:/  # scp传输，将本机镜像传输到其他服务器
   docker load < user-service.tar  # 解压镜像
   ```

4. **运行docker容器：** 通过 `docker-compose.yml` 文件，可以一次性启动多个服务，定义服务间的依赖关系、网络和存储卷等。

   * 创建 `docker-compose.yml` 文件：

     ```yml
     version: '3.8'
     
     services:
       my-local-mysql:
         image: zsq0216/my-local-mysql
         container_name: my-local-mysql
         restart: always
     
         ports:
           - "3308:3306"
         environment:
           MYSQL_ROOT_PASSWORD: 123456
           MYSQL_DATABASE: poetry
         networks:
           - my-network
     
       eureka-server:
         image: zsq0216/eureka-server
         container_name: eureka-server
         restart: always
         ports:
           - "8761:8761"
         networks:
           - my-network
     
       user-service:
         image: zsq0216/user-service
         container_name: user-service
         restart: always
         environment:
           SPRING_DATASOURCE_URL: jdbc:mysql://my-local-mysql:3306/poetry?serverTimezone=UTC
           SPRING_DATASOURCE_USERNAME: root
           SPRING_DATASOURCE_PASSWORD: 123456
           SPRING_DATASOURCE_DRIVERCLASSNAME: com.mysql.cj.jdbc.Driver
           EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka/
           SPRING_JPA_HIBERNATE_DIALECT: org.hibernate.dialect.MySQLDialect  
         ports:
           - "8081:8081"
         networks:
           - my-network
         depends_on:
           - my-local-mysql
           - eureka-server
       
       poem-service:
         image: zsq0216/poem-service
         container_name: poem-service
         restart: always
         environment:
           SPRING_DATASOURCE_URL: jdbc:mysql://my-local-mysql:3306/poetry?serverTimezone=UTC
           SPRING_DATASOURCE_USERNAME: root
           SPRING_DATASOURCE_PASSWORD: 123456
           SPRING_DATASOURCE_DRIVERCLASSNAME: com.mysql.cj.jdbc.Driver
           EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka/
           SPRING_JPA_HIBERNATE_DIALECT: org.hibernate.dialect.MySQLDialect  
         ports:
           - "8082:8082"  
         networks:
           - my-network
         depends_on:
           - my-local-mysql
           - eureka-server
     
       ai-chat-service:
         image: zsq0216/ai-chat-service
         container_name: ai-chat-service
         restart: always
         environment:
           EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka/
         ports:
           - "8085:8085"
         networks:
           - my-network
         depends_on:
           - eureka-server
     
       api-gateway:
         image: zsq0216/api-gateway
         container_name: api-gateway
         restart: always
         environment:
           EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka/
         ports:
           - "2345:2345"
         networks:
           - my-network
         depends_on:
           - eureka-server
     
     networks:
       my-network:
         driver: bridge
     ```

   * 运行 Docker Compose：

     ```shell
     # 运行
     docker-compose up -d
     
     # 查看容器状态
     docker-compose ps
     
     # 结束运行
     docker-compose down -v
     ```

### 4.5 微服务系统架构设计

#### 概述

在后端，服务以微服务架构形式提供，拆分为以下三个关键微服务：

1. **User Service (user-service)**:
   - **功能描述**：该服务主要负责用户管理，包括用户的注册、登录及其个人信息的管理。它提供了用户身份验证和授权功能，确保用户数据的安全性和隐私保护。
   - **职责范围**：处理用户账户的创建与管理，提供身份验证机制，维护用户个人资料，支持用户信息的查询和更新操作。
2. **Poem Service (poem-service)**:
   - **功能描述**：该服务专注于诗歌大会相关的业务逻辑，负责管理诗歌对战的流程和记录。它支持组织和管理诗歌对战活动，处理对战的规则和逻辑，并存储和检索对战记录。
   - **职责范围**：管理诗歌对战的创建、进行和记录，支持对战结果的存储和查询，提供对战统计和分析功能。
3. **AI Chat Service (ai-chat-service)**:
   - **功能描述**：该服务提供智能助手功能，利用先进的大模型技术回答用户提问。它负责处理自然语言理解和生成，提供与用户的智能对话服务。
   - **职责范围**：调用大规模预训练语言模型，处理用户的自然语言输入，生成相应的智能回复，支持多轮对话和上下文理解。

这些微服务通过标准化的API进行交互，共同构成了系统的整体功能，确保了系统的高效性和可扩展性。

#### 实现原理

```mermaid
graph TD;
  eureka-server["eureka-server"]
  user-service["user-service"]
  poem-service["poem-service"]
  ai-chat-service["ai-chat-service"]
  api-gateway["api-gateway"]

  user-service -->|8761| eureka-server
  poem-service -->|8761| eureka-server
  ai-chat-service -->|8761| eureka-server
  api-gateway -->|8761| eureka-server

  api-gateway -->|8081| user-service
  api-gateway -->|8082| poem-service
  api-gateway -->|8085| ai-chat-service

	前端应用-->|2345| api-gateway
```

eureka-server 提供服务注册和发现功能 。

user-service、poem-service 和 ai-chat-service 是微服务，连接到eureka-server 。

api-gateway 是 API 网关，连接到各个微服务。

##### (1) 服务注册与发现 - Eureka Server

**配置 Eureka Server**：

```yml
server:
  port: 8761

eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:${server.port}/eureka
    register-with-eureka: false
    fetch-registry: false
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.ip-address}:${spring.application.name}:${server.port}
```

Eureka Server 在启动时会成为服务注册中心，其他微服务可以在其上注册和发现。

**微服务注册**：

各个微服务（如 `user-service`、`poem-service`、`ai-chat-service`）在启动时通过配置   `EUREKA_CLIENT_SERVICEURL_DEFAULTZONE` 指向 `eureka-server`，实现自动注册。

```yml
environment:
  EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka/
```

每个微服务启动后，会自动将自身注册到 Eureka Server，Eureka Server 维护一个服务注册表，记录所有可用的服务实例。

##### (2) API 网关 - Spring Cloud Gateway

**配置 API 网关**：

- API 网关同样通过 `EUREKA_CLIENT_SERVICEURL_DEFAULTZONE` 配置与 Eureka Server 连接，以获取注册在 Eureka Server 上的所有微服务的实例信息。

```yml
api-gateway:
  image: zsq0216/api-gateway
  container_name: api-gateway
  restart: always
  environment:
    EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: http://eureka-server:8761/eureka/
  ports:
    - "2345:2345"
  networks:
    - my-network
  depends_on:
    - eureka-server
```

**请求路由**：

- API 网关负责接收客户端请求，并将其路由到相应的微服务。通过 Eureka Server，API 网关能够动态地发现和调用微服务实例，而不需要硬编码每个微服务的地址。
- API 网关还提供了负载均衡、安全性、监控等功能，确保请求的高效和安全传输。

##### (3) 工作流程

* **服务启动和注册**：`user-service`、`poem-service`、`ai-chat-service` 启动后，通过 Eureka Client 自动注册到 `eureka-server`。`eureka-server` 维护一个包含所有已注册服务实例的注册表。

* **API 网关配置和服务发现**：`api-gateway` 启动后，通过 Eureka Client 获取 `eureka-server` 上注册的所有服务信息。客户端请求通过 `api-gateway` 进入，API 网关根据请求路径和配置将请求路由到对应的微服务。

* **请求处理**：API 网关将请求转发到相应的微服务实例，如 `user-service` 处理用户相关请求，`poem-service` 处理诗歌相关请求，`ai-chat-service` 处理智能对话请求。微服务处理请求后，将响应返回给 API 网关，API 网关再将响应返回给客户端。

通过这种方式，Eureka Server 和 Spring Cloud Gateway 协同工作，实现了服务的动态注册与发现以及请求的统一路由和管理，构建了一个灵活、高效、可扩展的微服务架构。

### 4.6 用户个性化统计信息
#### 概述
用户个性化统计信息是指根据用户的学习行为和偏好，为用户提供个性化的学习数据和分析报告，帮助用户更好地了解自己的学习情况和提高学习效果。
#### 实现原理
1. **用户行为数据收集**：通过前端和后端的数据采集和处理，收集用户的学习行为数据，包括登录、注册、学习时长、学习内容、学习进度等。
2. **错题分析** 错题复习功能会展示在比赛中做错的题，显示题目与正确选项，并提供AI智能分析功能，为，帮助用户不断提高学习效果,我们还根据用户的复习频率进行错题的个性化推荐，并且接入AI智能分析功能，辅助错题复习。
3. **用户学习报告**：根据用户的学习行为和分析结果，生成个性化的学习报告，包括学习情况总览、学习进度、学习成绩、学习建议等，为用户提供参考和指导。
#### 概述
#### 实现原理
### 4.7 开场动画与进度条
#### 概述
进入网站时，会显示一个开场动画。
![[4.7-1.png]]
跳转到场景页面时，先显示一个进度条，表示当前的加载进度。
![[4.7-2.png]]
#### 实现原理
1. 编写页面，播放完成后自动跳转到场景页面。
2. 使用`Vuex store`管理3D场景的全局状态（是否加载完成），然后通过在主页面中挂载`<ProgressBar v-if="isProgressBar" :progress="loadingProgress" />`控制进度条的显示。
### 4.8 模型优化
1. 染色空间调整为线性颜色空间，语句为`renderer.outputColorSpace = THREE.LinearSRGBColorSpace`，避免模型呈现效果发灰。
2. 避免相机视角嵌入角色模型内部，当玩家处于第一人称模式时，隐藏自身角色模型。
3. 根据模型的高度动态调整相机高度，使其与视线基本平齐，呈现更加自然的视觉效果。
4. 预先加载行走和待机动作模型，实现人物模型在行走和待机状态间的自然切换。
### 4.9 主题房间
#### 概述
对不同的对战房间（3D）进行各具特色的场景布置，同时为每个房间设置对应的2D概念图和名称，为用户带来多样化的体验。
![](4.9-2.png)
![](4.9-1.png)
#### 实现原理
利用 AI 图像生成技术生成 2D 概念图，并运用开源的 Minecraft 贴图模型进行搭配上的选择，构建不同风格的 3D 场景。
### 4.10 UI设计与交互
#### 视觉设计
我们采用统一的视觉设计风格，包括颜色、字体、图标等，确保整体风格的一致性和美观性。并借助 Quasar 组件库提供的丰富组件和样式，实现了现代化的用户界面设计，AI辅助设计，提高了用户体验。
#### 交互设计
1. **登录注册**：用户可以通过输入用户名和密码进行登录，或者通过注册新账号进行注册。
2. **主页面**：用户登录后，会进入主页面，可以选择不同3D场景。
3. **场景页面**：用户可以进入3D场景，与其他用户进行互动，参与诗歌对战。
4. **对战页面**：用户可以选择对战房间，与其他用户进行诗歌对战，查看对战结果和记录。
5. **智能助手**：用户可以与AI智能导师进行对话，获取诗歌相关的信息和建议。
#### 宣传语
我们设计了宣传语“诗意联结，共襄盛会”，用于吸引用户的注意力，提高用户的参与度和体验感。


### 4.11 选手交互
以下是选手进入场景后的状态图。
```mermaid 
stateDiagram
    direction LR
    [*] --> 已准备 : 按"1"
    已准备 --> 比赛中 : 对手按"1"
    比赛中 --> 比赛结束
    比赛结束 --> [*] : 按"0"退出比赛
    比赛结束 --> 已准备 : 按"3"开启一轮新比赛
```

### 4.12 用户交互
用户间可以进行以下交互操作：
1. 文本聊天：用户可以通过输入框发送文本消息，与其他用户进行实时聊天。
2. 献花：用户可以与NPC 阮梅交互，进行买花、送花等操作。


### 4.13 代码风格与设计模式
#### 4.13.1 代码风格
1. 统一规范：遵循统一的代码规范，提升代码可读性和维护性。
模块化设计：采用组件化和模块化设计，确保代码的复用性和可维护性
2. 简化逻辑：使用setup语法糖简化组件逻辑，使代码更简洁。
组合式API:增强代码的可读性和组织性。这使得我们的代码更易于理解和维护
#### 4.13.2 设计模式
1. 在消息传递流程中使用了发布-订阅模式。
	- 当场景开始或完成加载时，会更新 isLoading 状态。
	- Vuex Store检测到 isLoading 状态的变化，并将其视为发布的消息。
	- 进度条组件接收消息后，根据 isLoading 状态的值更新自身的显示状态：
		- 若 isLoading 为 true，则显示进度条并开始模拟加载过程。
		- 若 isLoading 为 false，则隐藏进度条并重置进度值。
	![](./imgs/4.13.2-1.png)
2. WebSocket 可以被视作一种中介者模式的实现，因为中介者模式的核心思想是将多个对象的交互封装在一个中介类中，降低对象之间的耦合度，提高系统的灵活性。 而 WebSocket 在客户端和服务器之间建立了一个双向通信通道，并负责协调两者的交互。
3. Vue Router 前端路由框架实现了路由模式，其是构建单页面应用 (SPA) 的基石，将页面的不同状态与对应的 URL 路径进行映射，使得用户可以直接通过访问 URL 来切换页面状态。使用时，只需定义一个路由表即可获得该种模式的所有优点。




